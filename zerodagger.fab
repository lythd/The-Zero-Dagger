vars /game_vars
    CCC/levels level_ptr
    UU px = 128 // Player x and y are each 9 bits
    UU py = 128
    U sx = 128 // Scroll offset from player, technically negative, this is not the scroll value itself!
    U sy = 128
    U nmc = %00000000 // either %00 %01 %10 %11, name table coordinates

// charmaps can be used to get a nice syntax for defining levels.
charmap(".,-_#$")

// The levels are defined here:
data /levels
    [] level1
        ("#$#$#$#$#$#$#.#$#$#$.$#$#$#$#$#$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#$#$#$#$#$#.#$#$#$.$#$#$#$#$#$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#.#$#$#$#....$.$......#$#$#$#$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#.#...#.#$#.#$.$...........$$$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#...#.#...#..$#$......#$#$.$#$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#$#$#.#$#.#$...$.$#$#$#$#$.$#$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#.....#....$.$#$.$#$#$#$#$.$#$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#.#$#$#.#$#$.$#$.$#$#$#$#$.$#$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#.#......$.......$#$#$#$#$.$#$#....$#$#$#$#$#$#$#$#$#$#$#$#$#$"
         "#$#...#.#$#$.$#$#$.............................................."
         "#$#.#$#.#........$.$#$#$#$.$#$#$................................"
         "........#$#$#$#$#$....#$#$.$#$#$................#$#$#$.........."
         "#$#.#.#....$.$.....$#.#$.....$#$.....................$.........."
         "#$#.#.#$#$#$.$#$#$#$#.#$.....$#$.....................$.........."
         "#$#.#...............#.#$.....$#$.....................$.........."
         "#$#.#$#.#.#.#$#$..#.#.#$#$.$#$#$.....................$.........."
         "#$#.#...#$#.#.#$........#$.$#$#$........#$#$#$#$#$#$#$.........."
         "#$#$#.#.#...#.......#$#.#$.$#$#$................................"
         "......#$#$#$#.#$#$#$#$#.#$.$#$#$................................"
         "#$#.#$#.....#.#$#$#$....#$.$#$#$............-_-_................"
         "#$#.....#$#$#.#$#$#$....#$.$#$#$........-_-_-_-_-_.............."
         "#$#.#$.$#.........#$....#$.$#$#$..........-_-_-_-_-_............"
         "#$#$#$.$..#$.$....#$#.#$#$.$#$#$..............-_-_.............."
         "#$#....$.$#..$....#$#.#$....#$#$................................"
         "#$#.#$#$.$#$.$....#$#.#$....#$#$................................"
         "#$#.#.#$.$.$......#$#.......#$#$................................"
         "#$#.#....$.$......#$#$#$#.#$#$#$................................"
         "#$#....$.$.$#$#$#.#$#$#$#.#$#$#$................................"
         "#$#$#$#$.$#$#$#$#.#$#$#$#.#$#$#$................................"
         "#$#$#$#$.$#$#$#$#.#$#$#$#.#$#$#$................................"
         "................................................................"
         "................................................................"
         "................................................................"
         "............................-_.................................."
         "..........................-_-_-_................................"
         "..........................-_-_-_................................"
         "............................-_-_................................"
         "................................................................"
         "..................#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$.............."
         ".................................................$.............."
         ".................................................$.............."
         ".................................................$.............."
         ".................................................$.............."
         ".................................................$.............."
         ".................................................$.............."
         ".........................................#$#.....$#$#$#$........"
         "........................................$...........#..........."
         "........................................$...........#..........."
         "........................................$...........#..........."
         "........................................$...........#..........."
         "........................................$...........#..........."
         ".......................................#$#$#$#$#$#$$#..........."
         "....................................................#..........."
         "....................................................#..........."
         "....................................................#..........."
         "................................................................"
         "................................................................"
         "................................................................"
         "................................................................"
         "................................................................")

fn load_nametable(U nametable) // takes 0 1 2 or 3
    // Tell the NES which VRAM address we want to upload to:
    ppu_reset_addr($2000 + (UU(nametable) << 10)) // $2000, $2400, $2800, $2C00
    U i_start = (nametable & $01) << 5 // 0 or 32
    UU j_start = UU(U(nametable & $02) * U($0f)) // 0 or 30

    // Upload the tile data:
    for UU j = j_start; j < 30 + j_start; j += 1 // either 0<=j<30 or 30<=j<60 based on which nametable
        for U i = i_start; i < 32 + i_start; i += 1 // either 0<=i<32 or 32<=i<64 based on which nametable
            {PPUDATA}((level_ptr + j * 64)[i])

    // Then the attributes:
    for U i = 0; i < 64; i += 1
        {PPUDATA}((nametable << 6) | (nametable << 4) | (nametable << 2) | (nametable))
    
    //for U i = 0; i < 8; i += 1
    //    {PPUDATA}(%11111111)
    //for U j = 0; j < 6; j += 1
    //    {PPUDATA}(%10101010)
    //    for U i = 0; i < 6; i += 1
    //        {PPUDATA}(%00000000)
    //    {PPUDATA}(%01010101)
    //for U i = 0; i < 8; i += 1
    //    {PPUDATA}(%11111111)

fn load_level()
    load_nametable(%00)
    load_nametable(%01)
    load_nametable(%10)
    load_nametable(%11)

fn wait_sprite0_hit()
    U val = {PPUSTATUS}()
    while ((val & $40) == 0)
        val = {PPUSTATUS}()

asm fn wait_sprite_hit()
: employs
    vars
        U counter
    default
        //lda #0
    //label loop
        //sta &counter
        //inc &countner
        //bne loop
        //rts
        lda $2002          // Read PPUSTATUS to reset the Sprite 0 flag
    label loop
        bit $2002          // Check if Sprite 0 hit flag is set
        bvc loop  // Loop until it gets hit
        rts                // Return when the scanline is reached

nmi main_nmi()
    // Update OAM and poll the pads:
    ppu_upload_oam_poll_pads(0)

    // Turn on rendering:
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)
    
    // change scroll
    ppu_reset_scroll(0, 0)
    
    wait_sprite0_hit() // wait until sprite 0 is hit
    
    // Calculate scroll values and nametable coords based on the player coordinates and the scroll offset
    UU scrollx = (px - UU(sx)) 
    U uscrollx = U(scrollx & $00ff) // the x scroll fits perfectly into 256 so modulo can be done with &
    U pnmc = U((scrollx & $0100) >> 8) // %000000yx making a new name table coordinate based on the scroll
    
    UU scrolly = (py - UU(sy)) 
    if (scrolly & $8000) != 0
        scrolly += 480
    if scrolly >= $f0 // y is not so lucky, needs to be modulo 240
        scrolly -= $f0
        pnmc |= %10
    U uscrolly = U(scrolly)
    
    //U pnmc = U((px & $0100) >> 8) // %000000yx making a new name table coordinate based on the player coords
    //if py >= 240
        //pnmc |= $02
    
    if nmc != pnmc 
        nmc = pnmc
        {PPUCTRL}(PPUCTRL_NMI_ON | nmc) // update active nametable
    ppu_reset_scroll(uscrollx, uscrolly) // set scroll within nametable to sx, sy
    
    
mode main()
: nmi main_nmi
    // Set the palette:
    palette = example_palette
    ppu_upload_palette()

    // Set and load the level:
    level_ptr = @level1
    load_level()

    // Upload tilesheets
    
    state(M30_CHR(0))
    ppu_set_addr($0000)
    ppu_upload_pbz.chunks(ppu_upload_pbz.chunks(@chr_0, 0), 0)
    // state(M30_CHR(1))
    // ppu_set_addr($0000)
    // ppu_upload_pbz.chunks(ppu_upload_pbz.chunks(@chr_1, 0), 0)
    // state(M30_CHR(2))
    // ppu_set_addr($0000)
    // ppu_upload_pbz.chunks(ppu_upload_pbz.chunks(@chr_2, 0), 0)
    // state(M30_CHR(3))
    // ppu_set_addr($0000)
    // ppu_upload_pbz.chunks(ppu_upload_pbz.chunks(@chr_3, 0), 0)

    state(M30_CHR(0))

    // Tell the NES to trigger NMI once per frame:
    {PPUCTRL}(PPUCTRL_NMI_ON | nmc)

    // Wait forever, one frame at a time:
    while true
        update_pads()
        move_player() 
        update_sprites()
        nmi

fn update_sprites()
    // Our stack index into OAM:
    U i = 0

    // Push a sprite:
    U upx = U(px & $00ff)
    U upy = U(py & $00ff)
    set_oam_x(i, sx)     // x-position
    set_oam_y(i, sy - 1) // y-position
    set_oam_p(i, $20)    // tile
    set_oam_a(i, 0)      // options
    i += 4

    // Clear the remainder of OAM
    hide_oam(i)

fn move_player()    
    // Move the player horizontally based on button presses:
    if pads[0].held & BUTTON_LEFT
        if tile_at(px - 1, py) == '.' && tile_at(px - 1, py + 7) == '.'
            px -= 1
    else if pads[0].held & BUTTON_RIGHT
        if tile_at(px + 8, py) == '.' && tile_at(px + 8, py + 7) == '.'
            px += 1

    // Move the player vertically based on button presses:
    if pads[0].held & BUTTON_UP
        if tile_at(px, py - 1) == '.' && tile_at(px + 7, py - 1) == '.'
            py -= 1
    else if pads[0].held & BUTTON_DOWN
        if tile_at(px, py + 8) == '.' && tile_at(px + 7, py + 8) == '.'
            py += 1
    
    // Handle underflowing / overflowing, harder for py since mod 480 not mod 512 so not automatic and also have to handle over and under flow separately
    px &= $01ff
    if (py & $8000) != 0
        py += 480
    else if py >= 480
        py -= 480

fn tile_at(UU x, UU y) U
    // handle under/overflow
    if (y & $8000) != 0
        y += 480
    else if y >= 480
        y -= 480
    // Divide by 8 to get the tile position:
    x >>= 3
    y >>= 3

    // Return the tile:
    return (level_ptr + y * 64)[U(x)]

// Define the tileset (commonly called CHR):
data /pbz
    [] chr_0
         file(pbz, "tiles.png")
